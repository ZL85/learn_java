# 02_线程创建方式

## 方式一：继承`Thread`类

创建一个继承`Thread`类的子类，重写`Thread`类的`run()`方法，将此线程要执行的操作声明在此方法体中，创建当前`Thread`的子类对象，通过对象调用`start()`方法启动线程并调用当前线程的`run()`方法。

不能使用`pn.run()`替换`pn.start()`的调用，实现分线程的创建和调用。

不能让已经`start()`的线程再次执行`start()`，否则报异常`IllegalThreadStateException`，此时只能再`new`一个新的线程对象。

```java
public class EvenNumber {
    public static void main(String[] args) {
        // 创建当前Thread的子类对象，通过对象调用start()方法
        PrintEvenNumber pen = new PrintEvenNumber();
        pen.start();
//        pen.run(); //不会启动新线程
//        pen.start();

        PrintOddNumber pon = new PrintOddNumber();
        pon.start();

        // main所在的线程执行的操作
        for (int i = 1; i < 10001; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() + "：" + i);
            }
        }

        // 创建Thread类的匿名子类的匿名对象
        new Thread() {
            @Override
            public void run() {
                // 将此线程要执行的操作声明在此方法体中
                for (int i = 1; i < 10001; i++) {
                    if (i % 2 != 0) {
                        System.out.println(Thread.currentThread().getName() + "：" + i);
                    }
                }
            }
        }.start();
    }
}

// 创建一个继承Thread类的子类
class PrintEvenNumber extends Thread {
    // 重写Thread类的run()方法
    @Override
    public void run() {
        // 将此线程要执行的操作声明在此方法体中
        for (int i = 1; i < 10001; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() + "：" + i);
            }
        }
    }
}

class PrintOddNumber extends Thread {
    // 重写Thread类的run()方法
    @Override
    public void run() {
        // 将此线程要执行的操作声明在此方法体中
        for (int i = 1; i < 10001; i++) {
            if (i % 2 != 0) {
                System.out.println(Thread.currentThread().getName() + "：" + i);
            }
        }
    }
}
```

## 方式二：实现`Runnable`接口

创建一个实现`Runnable`接口的类，实现接口中的`run()`方法，将此线程要执行的操作声明在此方法体中，创建当前实现类的对象，将此对象当做参数传递到`Thread`类的构造器中，创建`Thread`类的实例，并使用`Thread`类的实例调用`start()`方法启动线程并调用当前线程的`run()`方法。

```java
public class PrintNumber2 {
    public static void main(String[] args) {
        // 创建当前实现类的对象
        PrintOddNumber2 pon2 = new PrintOddNumber2();
        PrintEvenNumber2 pen2 = new PrintEvenNumber2();

        // 将此对象当做参数传递到Thread类的构造器中，创建Thread类的实例
        Thread t1 = new Thread(pon2);
        Thread t2 = new Thread(pen2);

        t1.start();
        t2.start();

        // 创建Runnable接口匿名实现类的匿名对象
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i < 10001; i++) {
                    if (i % 2 == 0) {
                        System.out.println(Thread.currentThread().getName() + "：" + i);
                    }
                }
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i < 10001; i++) {
                    if (i % 2 != 0) {
                        System.out.println(Thread.currentThread().getName() + "：" + i);
                    }
                }
            }
        }).start();
    }
}

class PrintEvenNumber2 implements Runnable {
    // 实现接口中的run()方法
    @Override
    public void run() {
        // 将此线程要执行的操作声明在此方法体中
        for (int i = 1; i < 10001; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() + "：" + i);
            }
        }
    }
}

class PrintOddNumber2 implements Runnable {
    // 实现接口中的run()方法
    @Override
    public void run() {
        // 将此线程要执行的操作声明在此方法体中
        for (int i = 1; i < 10001; i++) {
            if (i % 2 != 0) {
                System.out.println(Thread.currentThread().getName() + "：" + i);
            }
        }
    }
}
```

对比两种方式：启动线程使用的都是`Thread`类中定义的`start()`方法，创建线程对象都是`Thread`类或其子类实例。不同的是一个是类的继承，一个是接口的实现。建议使用实现`Runnable`接口的方式，可以避免类的单继承性的局限性，更适合处理有共享数据的问题，实现了数据和代码的分离。

代理模式？`public class Thread implements Runnable`